## 설계 원칙: SOLID

### [1]. 단일 책임 원칙(Single responsibility principle; SRP)

- 객체 지향의 기본은 책임을 객체에게 할당하는 것이다.

  객체를 객체로 존재하게 하는 이유가 책임이며, 단일 책임 원칙은 이 책임과 관련된 원칙이다.

- **클래스는 단 한 개의 책임만을 가져야 한다**

  클래스가 여러 책임을 갖게 되면, 그 클래스는 각 책임마다 변경되는 이유가 발생한다.

  그래서, 반드시 한 개의 이유로만 변경되려면 한 개의 책임만을 가져야 한다.

- 객체에게 책임을 할당하는 것이 객체 설계의 기본인 만큼, 가장 중요하다.

- 단일 책임 원칙 위반 시, 한 책임의 구현 변경에 의해 다른 책임과 관련된 코드가 변경될 가능성이 높아진다.

  불필요한 변경 작업이 많아진다.


### [2]. 개방 폐쇄 원칙(Open-closed principle)

- 개방 폐쇄 원칙은 **확장에 열려 있어야 하고, 변경에는 닫혀 있어야 한다**
 
  좀 더 풀어서 이야기 해보면, **기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.**

- 기능을 수정했는데, 사용하는 코드를 수정하지 말라는 것이 이상하게 들리지만, 추상화를 통해서 해결이 가능하다.
  
  개방 폐쇄 원칙을 구현할 수 있는 이유는 확장되는 부분(변화되는 부분)을 추상화했기 떄문이다.

- 개방 폐쇄 원칙을 구현하는 다른 방법은 상속을 이용하는 것이다.

  상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 구현을 오버라이딩할 수 있기 때문이다.

- 개방 폐쇄 원칙을 깨뜨리는 행위 특징을 확인해보면,

  **비슷한 if-else 블록이 존재한다.** → 객체로 만들어 내 주입시켜서 패턴을 만들어 해결할 수 있다.

- 개방 폐쇄 원칙은 변경의 유연함과 관련된 원칙이다.

  기존 기능을 확장하기 위해서 기존 코드를 수정해준다면, 새로운 기능을 추가하는 것은 점점 어려워진다.

  확장에는 닫히고 변경에는 열리는 반대 상황이 발생하게 되는 문제점이 생긴다.

- 개방 폐쇄 원칙은 변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 할 수 있다.

  변화되는 부분을 추상화하지 안하면 개방 폐쇄 원칙을 지킬 수 없게 된다.


### [3]. 리스코프 치환 원칙(Liskov substitution principle)

- 개방 폐쇄 원칙은 추상화와 다형성을 이용해서 구현했는데,

  리스코프 치환 원칙은 개방 폐쇄 원칙을 받쳐 주는 다형성에 관한 원칙을 제공한다.

- **상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.**

  SuperClass와 SubClass가 있다고 하면,

  ```kotlin
  fun someMethod(sc: SuperClass) {
      sc.someMethod();
  }
  ```
  
  someMethod는 상위 타입인 SuperClass 타입의 객체를 사용하고 있는데, 

  이 메서드에 하위 타입의 객체를 전달해도 someMethod()가 정상적으로 동작해야 한다.
  
  ```kotlin
  someMethod(SubClass());
  ```
  
- 리스코프 치환 원칙이 제대로 지켜지지 않으면, 다형성에 기반한 개방 폐쇄 원칙 역시 지켜지지 않는다.

  그래서, 리스코프 치환 원칙을 지키는 것이 매우 중요하다.

- 
