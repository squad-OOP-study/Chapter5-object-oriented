# Chapter5  SOLID 설계 원칙

## SOLID
* SOLID 원칙은 SRP(단일 책임 원칙), OCP(개방 폐쇄 원칙), LSP(리스코프 치환 법칙), ISP(인터페이스 분리 원칙), DIP(의존성 역전 원칙)으로 줄여서 SOLID 원칙이라 합니다.
* SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해줍니다.
* 하지만 꼭 객체 지향 소프트웨어 설계 원칙에서만 적용된다는 뜻은 아니라는 것! 또한 원칙을 꼭 지킬 필요는 없다는 것!


## 1. 단일 책임 원칙 (Signle Responsibility Principle): SRP 원칙
### SRP 원칙이란 무엇인가
* 클래스는 단 한 개의 책임을 가져야 한다

### SRP 원칙이 지켜지지 않았을 떄 문제점
* 한 책임의 구현 변경에 의해 다른 책임과 관련된 코드가 변경될 가능성이 높아진다
* 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향이 비례해서 증가
* 결국, 코드를 절차 지향적으로 변하게 하여 유지 보수를 엉망으로 만드는 것
* 재사용을 어렵게 한다 
* 불필요한 페키지, 파일을 다른 책임이 가져야하는 문제 발생

### 책임과 변화
* 기능 변경 요구가 없을 때 수정에 대한 문제가 없다는 것 = 반대로 생각해 보면 책임의 단위는 변화되는 부분과 관련이 있다
* 책임의 단위는 변화되는 부분과 관련된다
* 각각의 책임은 서로 다른 이유로 변경되어야 한다
* 어떻게 서로 다른 이유로 변경되는 것을 알 수 있을까?  메소드를 실행하는 것이 누구인지 살펴보면 됨

### 의문
* 클래스가 여러 가지의 메소드를 가진다면, 복수의 책임을 갖는가?
* 클래스가 다중 상속 or 다중 구현을 한다면, 복수의 책임을 갖는가?
* 해당 클래스를 의존하는 사용자(클라이언트)가 여럿이라면 변경되는 이유는 여러가지가 되는가?
* SOLID를 창시한 로버트C 마틴 :  하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다
* 액터는 시스템이 동일한 방식으로 변경되기를 원하는 사용자 집단을 의미
* 액터는 한 명일수도 있고, 여러 명이 될 수도 있는 것
* SRP를 설계할 때는 거시적인 관점에서 해당 클래스에 어떤 액터가 의존하는지 고려하는 것이 바람직하다

## 2  OCP(개방 폐쇄 원칙)
### OCP 원칙이란 무엇인가
![image](https://user-images.githubusercontent.com/58967292/154813832-0c6a7c09-766e-406d-890e-dc105ec98c86.png)

* 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다
* 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다
* JDBC 매니저를 상속받는 PostgreSQL, Oracle, Sybase는 모두 변경에는 확장적이지만
* 자바 어플리케이션은 수정에 폐쇄적인 것
* 즉, 개방 폐쇄 원칙은 하나의 변화가 다른 곳에도 연쇄적으로 변화를 일으키는 것을 방지하기 위해 만들어졌다.

### ORP 원칙을 준수하는 방법
* 개방 폐쇄 원칙의 핵심은 변화하는 부분을 추상화하는 것
* 주로, 인터페이스를 통해서 구현
* 두 번째는 상속을 이용하는 것
``` Java
public class ResponseSender {
  private Data data;
  public ResponseSender(Data data) {
    this.data = data;

  }

  public Data getData() {
    return data;

  }
  
  public void send() {
    sendHeader();
    sendBody();
  }
  
  protected void sendHeader() {
    // 헤더 데이터 전송
  }
  
  protected void sendBody() {
    // 텍스트로 데이터 전송

  }
}
```
```Java
public class ZippedResponseSender extends ResponseSender {
  public ZippedResponseSender(Data data) {
    super(data);

  }

  @Override
  protected void sendBody() {
    // 데이터 압축 처리

  }

}
```
* ResponseSender 클래스의 send() 메소드는 헤더와 몸체 내용을 전송하기 위해 sendHeader() 메소드와 sendBody() 메소드를 차례대로 호출하며, 이 두 메소드는 알맞게 HTTP 응답 데이터를 생성합니다.
*  이때, 이 두 메소드는 protected 공개 범위를 갖고 있기 때문에 하위 클래스에서 오버라이딩이 가능
*  ZippedResponseSender 클래스는 기존 기능에 압축 기능을 추가해 주는데, 이 기능을 추가하기 위해 ResponseSender 클래스의 코드는 바뀌지 않았다
*  ResponseSender 클래스는 확장에는 열려 있으면서 변경에는 닫혀있는 것

### ORP 원칙을 지켜지지 않았을때 특징
* 다운 캐스팅을 한다
  * instanceof와 같은 타입 확인 연산자가 사용된다면 해당 코드는 개방 폐쇄 원칙을 위반할 가능성이 높다
  * 따라서 타입 캐스팅 후 실행되는 메소드가 변화 대상인지 확인해야 한다
* 비슷한 if~else 블록이 존재한다.
  * 새로운 기능,패턴이 요구될 때마다 if/else 블록이 추가되어 메소드 변경이 필요시되면 ORP 원칙이 깨진것 

### ORP 정리
* 개방 폐쇄 원칙은 유연함에 관련된 원칙
* 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도, 확장을 할 수 있게 만들어 준다
* 따라서, 우리는 개발을 하다가 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정할 수 있는지 확인해 보는 습관을 길러야 한다

## 리스코프 치환 원칙 : LSP 원칙
### 리스코프 치환 원칙 (Liskov Substitution Principle)의 정의
* 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다
* 특정 메소드가 상위 타입을 인자로 사용한다고 할 때, 그 타입의 하위 타입도 문제 없이 정상적으로 작동을 해야 한다
*  리스코프 치환 원칙이 제대로 지켜지지 않으면 다형성에 기반한 개방 폐쇄 원칙 역시 위반하는 것이기 때문에, 리스코프 치환 원칙을 지키는 것이 중요

### LSP 원칙이 지켜지지 않을 때
* 첫번째는 계약 위반. 함수를 사용할 때 아래와 같이 정해진 계약 혹은 명세를 지키지 않는 경우다.
  * 이상한 값 리턴
  * 이상한 기능 수행
  * 이상한 Exception 발행

* 확장 위반  
  * 확장을 하는데, 확장함으로써 기존 코드를 수정해야 하는 경우다. 상위타입만으로 프로그래밍을 할 수 없기 때문이다.
  * 확장을 하는데, 타입 확인( ex) instanceof)을 사용해 구현해야 하는경우, LSP 원칙이 깨진 것이다
  * 즉, 하위 타입이 추가되면, 계속 상위 타입을 사용하느 코드를 수정해줄 필요가 있다 =  개방 패쇠 원칙 위배

### 정리
* 리스코프 치환 원칙은 개방 폐쇄 원칙과 관련되어 있다. 
* 리스코프 치환 원칙을 어긴다면 확장 시 기존 코드를 계속 수정해주어야 한다. 
* 이는 '확장에는 열려있고 변경에는 닫혀있어야 한다' 라는 개방 폐쇄 원칙의 개념에 위반된다
* 상속을 잘 정의하여 치환 가능성을 위배되지 않도록 설계해야 

## ISP 원칙
### 인터페이스 분리 원칙 (Interface Segregation Principle)의 정의
* 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다
* 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
* 인터페이스를 분리하게 되면 인터페이스가 명확해지고, 대체 가능성이 높아진다.
* 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
→ 이렇게 분리함으로써 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.
사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리

### ISP 원칙이 지켜지지 않았을 때 발생가능 문제점
* 사용하지 않는 인터페이스 변경에 의해 발생하는 소스 재컴파일 문제
* 한 클라이언트으로 부터 발생하는 변경의 여파가 다른 클라이언트에 영향을 미치는 문제 => SRP 원칙과 연관됨  = 재사용성에 문제가 생김

### ISP 원칙을 지켰을 때 이점
* 클래스에 필요한 메소드만 선언할 수 있습니다.
* 재사용성이 높아집니다.
* 용도가 명확한 인터페이스를 제공할 수 있습니다

## 의존 역전 원칙 (DIP 원칙)
### 의존 역전 원칙 (Dependency Inversion Principle)의 정의
* 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
* 의존 관계를 맺을 때 자신보다 변하기 쉬운 것에 의존하지 마라
* 고수준 모듈: 어떤 의미 있는 단일 기능을 제공하는 모듈
* 저수준 모듈: 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현

### DIP 원칙이 지켜지지 않을때 발생가능 문제점
* 프로그램의 변경을 어렵게 만든다
* 저수준 모듈이 변경되면, 고수준 모듈에도 변경이 일어나는 문제 때문

### DIP 원칙을 지키기위한 실천법
* 변동성이 큰 구체(concrete) 클래스를 참조하지마라
  * 대신, 추상 인터페이스를 참조하라 
* 변동성이 큰 구체 클래스로 부터 파생하지마라
  * 상속은 소스코드에 존재하는 모든 관계중 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다
* 구체 함수를 오버라이드 하지말라
  * 구체함수는 소스 코드 의존성을 필요로 한다
  * 따라서 구체함수를 상속 및 오버라이드 하면 이러한 의존성을 제거할수 없게 되며, 의존성을 상속하게 된다
  * 추상 인터페이스 함수로 선언하고, 구현체들에게 각자 용도에 맞게 구현하는게 낫다

## SOLID 정리
* 단일 책임 원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아줍니다
* 객체가 단일 책임을 갖게 하고 클라이언트마다 다른 인터페이스를 사용하게 함으로써 한 기능의 변경이 다른 곳에까지 미치는 영향을 최소화할 수 있고, 이는 결국 기능 변경을 보다 쉽게 할 수 있도록 만들어 줍니다
* 리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원합니다.
* 개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서도 기존 코드를 수정하기 않도록 만들어 줍니다
* 변화되는 부분을 추상화할 수 있도록 도와주는 원칙이 바로 의존 역전 원칙
* 다형성을 도와주는 원칙이 리스코프 치환 원칙

