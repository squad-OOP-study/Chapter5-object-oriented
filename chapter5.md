# Chapter5-object-oriented

설계 원칙: SOLID feat(개발자가 반드시 정복해야할 객체 지향과 디자인 패턴)

1. 단일 책임 원칙(Single responsibility principle)

2. 개방 폐쇄 원칙(Open-closed principle)

3. 리스코프 치환 원칙(Liskov substitution principle)

4. 인터페이스 분리 원칙(Interface segregation principle)

4. 의존 역전 원칙(Dependency inversion principle)

## 1. 단일 책임 원칙

- 클래스는 단 하나만의 책임을 가져야한다.
- 클래스를 바꿀 상황이 생기면 바꾸려는 이유가 하나여야 한다.

### 단일 책임 원칙의 효과

1. 재사용성을 높인다
    - 단일 책임 원칙 미 준수시 타 클래스를 의존할때 필요없는 기능과 패키지 까지 가져오게 됨
    - 단일 책임 원칙 준수 시 클래스를 원하는 만큼만 가져다 씀으로써 재사용 성을 높인다.


2. 책임을 분리함으로써 변화에 대한 여파를 줄일 수 있다.
    - 단일 책임 원칙 미 준수시 한 클래스에서 책임들 끼리 의존할때 사용되는 책임의 변화시 수정할 부분이 많아진다.

```
단일 책임 원칙 미준수 상태에서
HTML 응답 문자열 에서 소켓으로 데이터를 로딩하는 방식이 바뀐다면
기존에 loadHtml()을 사용하는 모든 부분과 자료형을 바꾸어야한다.

그러나 기존 클래스에서 데이터 로드 클래스를 분리하고 DataDisplay 에서 데이터 로드 클래스의 loadData() 를 통해
구현한다면 로딩방식의 변화와 기존 클래스와는 무관할 것이다.
데이터 로드 클래스는 내부적으로 다양한 방법의 로딩 메서드를 갖고 외부와는 loadData() 를 통해서만 통신하면됨

// 미 준수 코드 
 class DataViewer {

    fun display() {
        val data = loadHtml()
        updataGui(data)
    }

    private fun loadHtml(): String {
        val client: HttpClient = HttpClient()
        client.connect(url)
        return client.getResponse()
    }
    
}
 
```

## 2. 개방 폐쇄 원칙

- 확장에는 열려 있어야하고 , 변경에는 닫혀 있어야한다.
- 기능에 변경과 확장은 가능하지만 그 기능을 사용하는 코드는 수정하지 않는다,

### 개방 폐쇄 원칙 구현 방법

1. 데이터 추상화
    - 추상화된 데이터 특히 인터페이스를 의존하고 있는 경우 구현체 클라스가 늘어나더라도(확장 O ) 의존 클래스는 변하지 않는다.(수정 X )

2. 상속
    - 상위 클래스의 기능을 사용 , 하위클래스에서 일부를 오버라이딩
    - 상위클래스의 기능으로 외부와 통신한다면 하위클래스에서 기능의 확장이 일어나더라도 수정 사항이 발생하지 않는다.

### 개방 폐쇄 원칙이 깨지는 증상

1. 다운 캐스팅 , instance of , is 연산자
    - 추상 타입이나 부모 타입에 의존할때 구현체 또는 자식 객체에 대해 다운 캐스팅

2. if - else 블록
    - 타입 혹은 인자의 구분을 위해 if - else 의 여러 분기문을 사용 클래스에서 추가하는것은 수정해 해당하고 지양해야 함
    - 해당 부분을 추상화하여 의존해야함
    - 추상화된 클래스의 내부적으로 if - else 문을 추가하는 것은 확장으로 볼 수 있음

```
- 코드와 같은 상황에서 결국 if-else 구문을 필요로한다.
- Enemy 클래스에 pathPatern 정보가 바뀌고 추가 될때 마다 코드가 변하는 것은 수정
- Pathpatern 클래스에 pathpatern 정보가 바뀌고 추가될 때마다 if-else 문에 추가되는 것은 확장이라고 볼 수 있음 

```

## 3. 리스코프치환 원칙

상위 타입이 제공하는 모든 기능을 하위 타입에서 문제 없지 지원할 수 있어야한다.

### 리스코프치환을 어기는 상황

1. 상위 클래스의 메서드가 하위 클래스에서 다른 잘못된 방식으로 동작 혹은 제공해선 안되는 기능 제공
2. 상위 타입에서 지정한 리턴값의 범위의 해당하지 않는 값을 리턴하는 것

### 사각형의 예

## 4. 인터페이스 분리 원칙

- 큰 인터페이스가 소수로 있는것 보단 작은 인터페이스가 많이 있는 것이 좋다.
- 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리하는 것이 좋다,
    - 의존의 양면성에 의해 클라이언트의 요구 변경으로 의존 클래스(B 클래스)의 수정이 이뤄질 수 있음
    - 인터페이스 분리 원칙이 지켜지지 않을 경우 해당 클래스(B 클래스)를 다른 기능으로 인해 의존하고 있는 클래스까지 수정이 이뤄 져야 함

## 5. 의존 역전 원칙

고수준 모듈 : 어떤 의미있는 단일 기능을 제공하는 모듈 (예 : Cafe)
저수준 모듈 : 고수준 모듈의 기능을 구현기 위해 필요한 하위기능의 실제 구현이 있는 모듈 (예 : Cashier , Barista , OrderQueue)

- 고수준의 모듈은 저수준의 모듈의 구현에 의존해서는 안되고, 저수준의 모듈이 고주준 모듈에서 정의한 추상타입에 의존해야한다.
- 고수준의 모듈은 추상 타입을 의존하고 저수준의 모듈은 해당 추상 타입을 구현하는 것이다.
    - 이를 통해 저수준의 모듈이 고수준의 모듈 ( 고수준이 제공하는 인터페이스) 를 의존하고 있는 형태로 역전된다.

### 의존 역전 원칙의 효과

1. 개방 폐쇄 원칙을 지킬 수 있게된다.
2. 각 패키지를 독립적으로 배포할 수 있게 해준다.


